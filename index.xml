<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lin</title>
    <link>http://04872.github.io/</link>
    <description>Recent content on Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 22 May 2023 21:24:01 +0800</lastBuildDate>
    
        <atom:link href="http://04872.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>多项式</title>
      <link>http://04872.github.io/post/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</link>
      <pubDate>Mon, 22 May 2023 21:24:01 +0800</pubDate>
      
      <guid>http://04872.github.io/post/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</guid>
      
        <description>&lt;h1 id=&#34;整除&#34;&gt;整除&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;带余除法&lt;/strong&gt; 对于P[x]上的任意两个多项式 f(x) 和 g(x)，其中 $g(x)\neq 0$，则一定有 $P[x]$ 中的多项式 $q(x)$、$r(x)$ 存在，使得&lt;/p&gt;
&lt;p&gt;$$f(x) = q(x)g(x)+r(x)$$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt; : 过程就是带余除法的过程.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>MySQL锁简介</title>
      <link>http://04872.github.io/post/mysql%E9%94%81%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 19 Apr 2023 18:37:55 +0800</pubDate>
      
      <guid>http://04872.github.io/post/mysql%E9%94%81%E7%AE%80%E4%BB%8B/</guid>
      
        <description>&lt;h1 id=&#34;mysql的各种锁简介&#34;&gt;MySQL的各种锁简介&lt;/h1&gt;
&lt;h2 id=&#34;一全局锁&#34;&gt;一、全局锁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;全局锁是怎么用的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要使用全局锁，则要执行这条命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行后，&lt;strong&gt;整个数据库就处于只读状态了&lt;/strong&gt;，这时其他线程执行以下操作，都会被阻塞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对数据的增删改操作，比如 insert、delete、update等语句；&lt;/li&gt;
&lt;li&gt;对表结构的更改操作，比如 alter table、drop table 等语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果要释放全局锁，则要执行这条命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然，当会话断开了，全局锁会被自动释放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全局锁应用场景是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局锁主要应用于做&lt;strong&gt;全库逻辑备份&lt;/strong&gt;，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。&lt;/p&gt;
&lt;h2 id=&#34;二-表级锁&#34;&gt;二、 表级锁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;MySQL 表级锁有哪些？具体怎么用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MySQL 里面表级别的锁有这几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元数据锁（MDL）;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意向锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUTO-INC 锁；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;表锁&#34;&gt;表锁&lt;/h3&gt;
&lt;p&gt;表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。&lt;/p&gt;
&lt;p&gt;也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。&lt;/p&gt;
&lt;p&gt;另外，当会话退出后，也会释放所有表锁。&lt;/p&gt;
&lt;p&gt;不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。&lt;/p&gt;
&lt;h3 id=&#34;元数据锁mdl&#34;&gt;元数据锁(MDL)&lt;/h3&gt;
&lt;p&gt;我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对一张表进行 CRUD 操作时，加的是 &lt;strong&gt;MDL 读锁&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;对一张表做结构变更操作的时候，加的是 &lt;strong&gt;MDL 写锁&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。&lt;/p&gt;
&lt;p&gt;当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。&lt;/p&gt;
&lt;p&gt;反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MDL 不需要显示调用，那它是在什么时候释放的?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MDL 是在事务提交后才会释放，这意味着&lt;strong&gt;事务执行期间，MDL 是一直持有的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；&lt;/li&gt;
&lt;li&gt;然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；&lt;/li&gt;
&lt;li&gt;接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是因为申请 MDL 锁的操作会形成一个队列，队列中&lt;strong&gt;写锁获取优先级高于读锁&lt;/strong&gt;，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。&lt;/p&gt;
&lt;p&gt;所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。&lt;/p&gt;
&lt;h2 id=&#34;三行级锁&#34;&gt;三、行级锁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；&lt;/li&gt;
&lt;li&gt;在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>MySQL索引面试题</title>
      <link>http://04872.github.io/post/mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 17 Apr 2023 14:54:46 +0800</pubDate>
      
      <guid>http://04872.github.io/post/mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      
        <description>&lt;h1 id=&#34;mysql索引面试题&#34;&gt;MySQL索引面试题&lt;/h1&gt;
&lt;h3 id=&#34;1-索引分类&#34;&gt;1. &lt;strong&gt;索引分类&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按「数据结构」分类：&lt;strong&gt;B+tree索引、Hash索引、Full-text索引&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按「物理存储」分类：&lt;strong&gt;聚簇索引（主键索引）、二级索引（辅助索引）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按「字段特性」分类：&lt;strong&gt;主键索引、唯一索引、普通索引、前缀索引&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。&lt;/li&gt;
&lt;li&gt;唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。&lt;/li&gt;
&lt;li&gt;普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。&lt;/li&gt;
&lt;li&gt;前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按「字段个数」分类：&lt;strong&gt;单列索引、联合索引&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。&lt;/p&gt;
&lt;p&gt;在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果有主键，默认会使用主键作为聚簇索引的索引键（key）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；
其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是 B+Tree 索引。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;通过二级索引查询商品数据的过程&#34;&gt;通过二级索引查询商品数据的过程&lt;/h4&gt;
&lt;p&gt;主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；&lt;/li&gt;
&lt;li&gt;二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;联合索引&#34;&gt;联合索引&lt;/h4&gt;
&lt;p&gt;通过将多个字段组合成一个索引，该索引就被称为联合索引。&lt;/p&gt;
&lt;p&gt;比如，如果创建了一个 (a, b, c) 联合索引，联合索引查询的 B+Tree 是先按 a 进行排序，然后再 a 相同的情况再按 b 字段排序，然后再 b 相同的情况再按 c 字段排序。&lt;/p&gt;
&lt;p&gt;如果查询条件是以下这几种，就可以匹配上联合索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where a=1；&lt;/li&gt;
&lt;li&gt;where a=1 and b=2 and c=3；&lt;/li&gt;
&lt;li&gt;where a=1 and b=2；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。&lt;/p&gt;
&lt;p&gt;但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where b=2；&lt;/li&gt;
&lt;li&gt;where c=3；&lt;/li&gt;
&lt;li&gt;where b=2 and c=3；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。&lt;strong&gt;利用索引的前提是索引里的 key 是有序的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行where a = 2 and b = 7是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。&lt;/p&gt;
&lt;h3 id=&#34;2-索引底层使用了什么数据结构和算法&#34;&gt;2. &lt;strong&gt;索引底层使用了什么数据结构和算法？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;B+树、Hash表、 FULL-TEXT&lt;/p&gt;
&lt;h3 id=&#34;3-为什么-mysql-innodb-选择-btree-作为索引的数据结构&#34;&gt;3. &lt;strong&gt;为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。&lt;/li&gt;
&lt;li&gt;另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。&lt;/li&gt;
&lt;li&gt;对于有 N 个叶子节点的 B+Tree，其搜索复杂度为$\mathcal{O}(\log_{d}N)$，其中 d 表示节点允许的最大子节点个数为 d 个。&lt;/li&gt;
&lt;li&gt;在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。&lt;/li&gt;
&lt;li&gt;而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 $\mathcal{O}(\log N)$，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作。&lt;/p&gt;
&lt;p&gt;而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。&lt;/p&gt;
&lt;p&gt;但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。&lt;/p&gt;
&lt;p&gt;而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。&lt;/p&gt;
&lt;p&gt;另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。&lt;/p&gt;
&lt;h3 id=&#34;4-什么时候适用索引&#34;&gt;4. &lt;strong&gt;什么时候适用索引？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要占用物理空间，数量越大，占用空间越大；&lt;/li&gt;
&lt;li&gt;创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；&lt;/li&gt;
&lt;li&gt;会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，索引不是万能钥匙，它也是根据场景来使用的，以下情况适用索引。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字段有唯一性限制的，比如商品编码；&lt;/li&gt;
&lt;li&gt;经常用于 &lt;code&gt;WHERE&lt;/code&gt; 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。&lt;/li&gt;
&lt;li&gt;经常用于 &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-什么时候不需要创建索引&#34;&gt;5. &lt;strong&gt;什么时候不需要创建索引？&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 条件，&lt;code&gt;GROUP BY&lt;/code&gt;，&lt;code&gt;ORDER BY&lt;/code&gt; 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。&lt;/li&gt;
&lt;li&gt;字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。&lt;/li&gt;
&lt;li&gt;表数据太少的时候，不需要创建索引；&lt;/li&gt;
&lt;li&gt;经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-什么情况下索引会失效&#34;&gt;6. &lt;strong&gt;什么情况下索引会失效？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这里简单说一下，发生索引失效的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我们使用左或者左右模糊匹配的时候，也就是 &lt;code&gt;like %xx&lt;/code&gt; 或者 &lt;code&gt;like %xx%&lt;/code&gt;这两种方式都会造成索引失效；&lt;/li&gt;
&lt;li&gt;当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；&lt;/li&gt;
&lt;li&gt;联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。&lt;/li&gt;
&lt;li&gt;在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-有什么优化索引的方法&#34;&gt;7. &lt;strong&gt;有什么优化索引的方法？&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前缀索引优化；&lt;/p&gt;
&lt;p&gt;前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引。&lt;/p&gt;
&lt;p&gt;使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。&lt;/p&gt;
&lt;p&gt;不过，前缀索引有一定的局限性，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order by 就无法使用前缀索引；&lt;/li&gt;
&lt;li&gt;无法把前缀索引用作覆盖索引；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖索引优化；&lt;/p&gt;
&lt;p&gt;覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。&lt;/p&gt;
&lt;p&gt;假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？&lt;/p&gt;
&lt;p&gt;我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。&lt;/p&gt;
&lt;p&gt;所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主键索引最好是自增的；&lt;/p&gt;
&lt;p&gt;我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？&lt;/p&gt;
&lt;p&gt;InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们使用自增主键&lt;/strong&gt;，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次&lt;strong&gt;插入一条新记录，都是追加操作，不需要重新移动数据&lt;/strong&gt;，因此这种插入数据的方法效率非常高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们使用非自增主键&lt;/strong&gt;，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为&lt;strong&gt;页分裂&lt;/strong&gt;。&lt;strong&gt;页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止索引失效；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>项目简介</title>
      <link>http://04872.github.io/post/%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 11 Apr 2023 15:49:57 +0800</pubDate>
      
      <guid>http://04872.github.io/post/%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/</guid>
      
        <description>&lt;h2 id=&#34;项目介绍&#34;&gt;&lt;strong&gt;项目介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么要做这样一个项目？&lt;/p&gt;
&lt;p&gt;学习网络编程知识和锻炼实践能力.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;介绍下你的项目&lt;/p&gt;
&lt;p&gt;Linux下C++轻量级Web服务器。参考《Linux高性能服务器编程》&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;strong&gt;线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和Proactor均实现)&lt;/strong&gt; 的并发模型&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;状态机&lt;/strong&gt;解析HTTP请求报文，支持解析&lt;strong&gt;GET和POST&lt;/strong&gt;请求&lt;/li&gt;
&lt;li&gt;经Webbench压力测试可以实现&lt;strong&gt;上万的并发连接&lt;/strong&gt;数据交换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池相关&#34;&gt;&lt;strong&gt;线程池相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;手写线程池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程的同步机制有哪些？&lt;/p&gt;
&lt;p&gt;互斥锁和信号量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程池中的工作线程是一直等待吗？&lt;/p&gt;
&lt;p&gt;不是，会一直从任务队列取任务来执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你的线程池工作线程处理完一个任务后的状态是什么？&lt;/p&gt;
&lt;p&gt;释放该资源，等待执行下一任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？&lt;/p&gt;
&lt;p&gt;新来请求的要排队等着空闲线程处理，现在是固定线程池，最好的动态创建线程池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?&lt;/p&gt;
&lt;p&gt;会影响，使用异步的策略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并发模型相关&#34;&gt;&lt;strong&gt;并发模型相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单说一下服务器使用的并发模型？&lt;/p&gt;
&lt;p&gt;同步io模拟proactor+threadpool+epoll&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reactor、proactor、主从reactor模型的区别？&lt;/p&gt;
&lt;p&gt;主要就是主线程是否处理读写的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http报文解析相关&#34;&gt;&lt;strong&gt;HTTP报文解析相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用了状态机啊，为什么要用状态机？&lt;/li&gt;
&lt;li&gt;状态机的转移图画一下&lt;/li&gt;
&lt;li&gt;GET和POST的区别&lt;/li&gt;
&lt;li&gt;最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。&lt;/li&gt;
&lt;li&gt;GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。&lt;/li&gt;
&lt;li&gt;GET请求在URL中传送的参数是有长度限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。&lt;/li&gt;
&lt;li&gt;GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
  </channel>
</rss>
