<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lin</title>
    <link>http:04872.github.io/</link>
    <description>Recent content on Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 12 Jul 2023 21:23:37 +0800</lastBuildDate>
    
        <atom:link href="http:04872.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>线性方程组的求解</title>
      <link>http:04872.github.io/post/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%B1%82%E8%A7%A3/</link>
      <pubDate>Wed, 12 Jul 2023 21:23:37 +0800</pubDate>
      
      <guid>http:04872.github.io/post/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E6%B1%82%E8%A7%A3/</guid>
      
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;矩阵及其初等行变换&#34;&gt;矩阵及其初等行变换&lt;/h1&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;矩阵的初等行变换中，对换变换可以通过倍乘变换和倍加变换来实现&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实任意一个矩阵$A = (a_{ij})&lt;em&gt;{n\times m}$都可以经过行的倍加变换化为行阶梯形矩阵。证明这个结论的关键在于：证明可以通过倍加行变换 “$r_j+kr_i$” 将$a&lt;/em&gt;{i1}(j\geq 2)$化为$0$，然后我们对矩阵的行数和列数作归纳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;矩阵等价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个矩阵可以经过初等变换化为另一个矩阵，则称这两个矩阵之间等价。&lt;/p&gt;
&lt;h1 id=&#34;n维向量&#34;&gt;n维向量&lt;/h1&gt;
&lt;h2 id=&#34;向量组的等价&#34;&gt;向量组的等价&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线性表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设向量$\alpha$和向量组$\beta_1,\beta_2,\ldots,\beta_n$，如果存在数$k_1,k_2,\ldots,k_n$使得成立&lt;/p&gt;
&lt;p&gt;$$\alpha = \sum_{i=1}^{n}k_i\beta_i$$，&lt;/p&gt;
&lt;p&gt;则称$\alpha$能由向量组$\beta_1,\beta_2,\ldots,\beta_n$线性表示。&lt;/p&gt;
&lt;p&gt;如果向量组$\alpha_1,\alpha_2,\ldots,\alpha_n$中每个向量都能由向量组$\beta_1,\beta_2,\ldots,\beta_n$线性表示，则称$\alpha_1,\alpha_2,\ldots,\alpha_n$能由&lt;/p&gt;
&lt;p&gt;$\beta_1,\beta-2,\ldots,\beta_n$线性表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向量组等价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果两组向量组可以相互线性表示，则称这两组向量组等价。容易验证，向量组的等价这一关系是一个等价关系。&lt;/p&gt;
&lt;p&gt;同型的矩阵之间，如果列（行）向量组等价，那么这两个矩阵等价，反之不一定成立。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性相关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设向量组$\alpha_1,\alpha_2,\ldots,\alpha_s\in F^{n}$，如果存在不全为零的数$k_1，k_2,\ldots,k_s$，使得&lt;/p&gt;
&lt;p&gt;$$k_1\alpha_2+k_2\alpha_2+\cdots+k_s\alpha_s=\theta$$&lt;/p&gt;
&lt;p&gt;则称这个向量组线性相关，否则线性无关。&lt;/p&gt;
&lt;p&gt;根据以上定义，我们可以得到以下常用结论&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;含有零向量的向量组一定线性相关。&lt;/li&gt;
&lt;li&gt;单独一个向量$\alpha$线性相关$\Leftrightarrow \alpha = \theta$.&lt;/li&gt;
&lt;li&gt;如果$\alpha_1,\alpha_2,\ldots,\alpha_s$线性相关，那么$\alpha_1,\alpha_2,\ldots,\alpha_s,\alpha_{s+1},\ldots,\alpha_t$线性相关.&lt;/li&gt;
&lt;li&gt;如果$\alpha_1,\alpha_2,\ldots,\alpha_s,\alpha_{s+1},\ldots,\alpha_t$线性无关，那么$\alpha_1,\alpha_2,\ldots,\alpha_s$线性无关.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;定理1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向量组$\alpha_1,\alpha_2,\ldots,\alpha_s(s\geq 2)$线性线关$\Leftrightarrow \exists \alpha_i$可以由向量组中其它向量线性表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设$\alpha_1,\alpha_2,\ldots,\alpha_s$线性无关，$\alpha_1,\alpha_2,\ldots,\alpha_s,\beta$线性相关，那么$\beta$可由$\alpha_1,\alpha_2,\ldots,\alpha_s$线性表示，且表示方式唯一。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>哈希表章节所用数据结构</title>
      <link>http:04872.github.io/post/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AB%A0%E8%8A%82%E6%89%80%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 28 Jun 2023 19:45:18 +0800</pubDate>
      
      <guid>http:04872.github.io/post/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AB%A0%E8%8A%82%E6%89%80%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      
        <description>&lt;h1 id=&#34;unorder_map&#34;&gt;unorder_map&lt;/h1&gt;
&lt;h2 id=&#34;无序关联式容器&#34;&gt;无序关联式容器&lt;/h2&gt;
&lt;p&gt;​	一类“特殊”的关联式容器，它们常被称为“无序容器”、“哈希容器”或者“无序关联容器”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，无序容器是 &lt;a href=&#34;http://c.biancheng.net/cplus/&#34;&gt;C++&lt;/a&gt; 11 标准才正式引入到 &lt;a href=&#34;http://c.biancheng.net/stl/&#34;&gt;STL&lt;/a&gt; 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，它们有本质上的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；&lt;/li&gt;
&lt;li&gt;无序容器的底层实现采用的是哈希表的存储结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。有关哈希表存储结构，读者可阅读《&lt;a href=&#34;http://c.biancheng.net/view/3437.html&#34;&gt;哈希表(散列表)详解&lt;/a&gt;》一文做详细了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于底层实现采用了不同的&lt;a href=&#34;http://c.biancheng.net/data_structure/&#34;&gt;数据结构&lt;/a&gt;，因此和关联式容器相比，无序容器具有以下 2 个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。&lt;/p&gt;
&lt;p&gt;​	表 1 对这 4 种无序容器的功能做了详细的介绍。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;无序容器&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;unordered_map&lt;/td&gt;
&lt;td&gt;存储键值对 &amp;lt;key, value&amp;gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered_multimap&lt;/td&gt;
&lt;td&gt;和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered_set&lt;/td&gt;
&lt;td&gt;不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered_multiset&lt;/td&gt;
&lt;td&gt;和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;unordered_set&#34;&gt;unordered_set&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，此时unordered_set。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;unordered_set 类模板中，提供了如表 2 所示的成员方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员方法&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;begin()&lt;/td&gt;
&lt;td&gt;返回指向容器中第一个元素的正向迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;end();&lt;/td&gt;
&lt;td&gt;返回指向容器中最后一个元素之后位置的正向迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cbegin()&lt;/td&gt;
&lt;td&gt;和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cend()&lt;/td&gt;
&lt;td&gt;和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty()&lt;/td&gt;
&lt;td&gt;若容器为空，则返回 true；否则 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;size()&lt;/td&gt;
&lt;td&gt;返回当前容器中存有元素的个数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max_size()&lt;/td&gt;
&lt;td&gt;返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;find(key)&lt;/td&gt;
&lt;td&gt;查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;count(key)&lt;/td&gt;
&lt;td&gt;在容器中查找值为 key 的元素的个数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equal_range(key)&lt;/td&gt;
&lt;td&gt;返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emplace()&lt;/td&gt;
&lt;td&gt;向容器中添加新元素，效率比 insert() 方法高。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emplace_hint()&lt;/td&gt;
&lt;td&gt;向容器中添加新元素，效率比 insert() 方法高。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert()&lt;/td&gt;
&lt;td&gt;向容器中添加新元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;erase()&lt;/td&gt;
&lt;td&gt;删除指定元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clear()&lt;/td&gt;
&lt;td&gt;清空容器，即删除容器中存储的所有元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;swap()&lt;/td&gt;
&lt;td&gt;交换 2 个 unordered_set 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket_count()&lt;/td&gt;
&lt;td&gt;返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max_bucket_count()&lt;/td&gt;
&lt;td&gt;返回当前系统中，unordered_set 容器底层最多可以使用多少桶。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket_size(n)&lt;/td&gt;
&lt;td&gt;返回第 n 个桶中存储元素的数量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket(key)&lt;/td&gt;
&lt;td&gt;返回值为 key 的元素所在桶的编号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load_factor()&lt;/td&gt;
&lt;td&gt;返回 unordered_set 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max_load_factor()&lt;/td&gt;
&lt;td&gt;返回或者设置当前 unordered_set 容器的负载因子。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rehash(n)&lt;/td&gt;
&lt;td&gt;将当前容器底层使用桶的数量设置为 n。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reserve()&lt;/td&gt;
&lt;td&gt;将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳 count 个元（不超过最大负载因子）所需的数量，并重新整理容器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hash_function()&lt;/td&gt;
&lt;td&gt;返回当前容器使用的哈希函数对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;unordered_map&#34;&gt;unordered_map&lt;/h3&gt;
&lt;p&gt;C++ STL 标准库中，unordered_map 容器迭代器的类型为前向迭代器（又称正向迭代器）。这意味着，假设 p 是一个前向迭代器，则其只能进行 *p、p++、++p 操作，且 2 个前向迭代器之间只能用 == 和 != 运算符做比较。&lt;/p&gt;
&lt;p&gt;以下是C++ unordered_map迭代器相关成员方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员方法&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;begin()&lt;/td&gt;
&lt;td&gt;返回指向容器中第一个键值对的正向迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;end()&lt;/td&gt;
&lt;td&gt;返回指向容器中最后一个键值对之后位置的正向迭代器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cbegin()&lt;/td&gt;
&lt;td&gt;和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cend()&lt;/td&gt;
&lt;td&gt;和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;find(key)&lt;/td&gt;
&lt;td&gt;查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;c中map&#34;&gt;C++中map&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;映射&lt;/th&gt;
&lt;th&gt;底层实现&lt;/th&gt;
&lt;th&gt;是否有序&lt;/th&gt;
&lt;th&gt;数值是否可以重复&lt;/th&gt;
&lt;th&gt;能否更改数值&lt;/th&gt;
&lt;th&gt;查询效率&lt;/th&gt;
&lt;th&gt;增删效率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;std::map&lt;/td&gt;
&lt;td&gt;红黑树&lt;/td&gt;
&lt;td&gt;key有序&lt;/td&gt;
&lt;td&gt;key不可重复&lt;/td&gt;
&lt;td&gt;key不可修改&lt;/td&gt;
&lt;td&gt;O(log n)&lt;/td&gt;
&lt;td&gt;O(log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;std::multimap&lt;/td&gt;
&lt;td&gt;红黑树&lt;/td&gt;
&lt;td&gt;key有序&lt;/td&gt;
&lt;td&gt;key可重复&lt;/td&gt;
&lt;td&gt;key不可修改&lt;/td&gt;
&lt;td&gt;O(log n)&lt;/td&gt;
&lt;td&gt;O(log n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;std::unordered_map&lt;/td&gt;
&lt;td&gt;哈希表&lt;/td&gt;
&lt;td&gt;key无序&lt;/td&gt;
&lt;td&gt;key不可重复&lt;/td&gt;
&lt;td&gt;key不可修改&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。&lt;/p&gt;
&lt;p&gt;同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。&lt;/p&gt;
&lt;h3 id=&#34;c-string&#34;&gt;C++ string&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;成员方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;resize(n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将string容量修改为n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;reverse(left,right)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;反转[left,right)之间的字符串，left为迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
      
    </item>
    
    <item>
      <title>多项式</title>
      <link>http:04872.github.io/post/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</link>
      <pubDate>Mon, 22 May 2023 21:24:01 +0800</pubDate>
      
      <guid>http:04872.github.io/post/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</guid>
      
        <description>&lt;h1 id=&#34;整除&#34;&gt;整除&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;带余除法&lt;/strong&gt; &lt;em&gt;对于 $P[x]$ 上的任意两个多项式 $f(x)$ 和 $g(x)$，其中 $g(x)\neq 0$，则一定有 $P[x]$ 中的多项式 $q(x)$、$r(x)$ 存在，使得&lt;/em&gt;
&lt;em&gt;$$f(x) = q(x)g(x)+r(x).$$&lt;/em&gt;
&lt;strong&gt;证明&lt;/strong&gt; : 过程就是带余除法的过程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义1&lt;/strong&gt; &lt;em&gt;称数域 $P$ 上的多项式  $g(x)$ 整除 $f(x)$ ，如果有数域 $P$ 上的多项式 $h(x)$ 使得&lt;/em&gt;
&lt;em&gt;$$f(x) = g(x)h(x).$$&lt;/em&gt;
&lt;em&gt;我们用 “$g(x)\mid f(x)$” 表示 $g(x)$ 整除 $f(x)$，用 “$g(x)\nmid f(x)$” 表示 $g(x)$ 不整除 $f(x)$.&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;整除关系不随数域的改变而改变&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;定理1&lt;/strong&gt; &lt;em&gt;对于数域 $P$ 上的任意两个多项式 $f(x)$，$g(x)$，其中 $g(x)\neq 0$, $g(x)\mid f(x)$ 的充要条件是 $g(x)$ 除 $f(x)$ 的余数是零.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt; 充分性：如果 $r(x)=0$，那么 $f(x) = q(x)g(x)$，所以整除.
必要性：根据整除定义，$f(x) = q(x)g(x)=q(x)g(x)+0$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整除性质1&lt;/strong&gt; &lt;em&gt;如果 $f(x)$ 和 $g(x)$ 相互整除，那么存在非零常数 $c$，使得 $f(x)=cg(x)$.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt; 有 $f(x)h_1(x) = g(x)$，$g(x)h_2(x)=f(x)$.&lt;/p&gt;
&lt;p&gt;​		$\Rightarrow f(x)h_1(x)h_2(x) = f(x)$.
​		如果 $f(x)=0$，那么 $g(x) = 0$，命题显然成立.&lt;/p&gt;
&lt;p&gt;​		如果 $f(x)\neq 0$，由多项式乘法消去律消去 $f(x)$ 得，$h_1(x)h_2(x) = 1$，那么 $\partial(h_1(x))+\partial(h_2(x)) = 0$.&lt;/p&gt;
&lt;p&gt;所以 $\partial(h_1(x)) = \partial(h_2(x))=0$.  那么 $c$ 取 $h_2(x)$ 即可.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整除性质2（传递性）&lt;/strong&gt; &lt;em&gt;如果 $f(x)\mid g(x)$，$g(x)\mid h(x)$，那么 $f(x)\mid h(x)$.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt; 根据整除定义简单验证即可.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整除性质3&lt;/strong&gt; &lt;em&gt;如果 $f(x)\mid g_i(x),\quad i=1,2,3,\cdots,r$，那么&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;$$f(x)\mid \sum_{i=1}^{r}u_i(x)g_i(x).$$&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其中 $u_i(x)\in P[x]$.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt; 对任意 正整数$1\leq i\leq r$，存在 $h_i(x)\in P[x]$，使得 $g_i(x) = f(x)h_i(x)$.&lt;/p&gt;
&lt;p&gt;所以 $\sum_{i=1}^{r}u_i(x)g_i(x) = \sum_{i=1}^{r}u_i(x)h_i(x)f(x) = f(x)\sum_{i=1}^{r}u_i(x)h_i(x)$.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>MySQL锁简介</title>
      <link>http:04872.github.io/post/mysql%E9%94%81%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 19 Apr 2023 18:37:55 +0800</pubDate>
      
      <guid>http:04872.github.io/post/mysql%E9%94%81%E7%AE%80%E4%BB%8B/</guid>
      
        <description>&lt;h1 id=&#34;mysql的各种锁简介&#34;&gt;MySQL的各种锁简介&lt;/h1&gt;
&lt;h2 id=&#34;一全局锁&#34;&gt;一、全局锁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;全局锁是怎么用的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要使用全局锁，则要执行这条命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行后，&lt;strong&gt;整个数据库就处于只读状态了&lt;/strong&gt;，这时其他线程执行以下操作，都会被阻塞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对数据的增删改操作，比如 insert、delete、update等语句；&lt;/li&gt;
&lt;li&gt;对表结构的更改操作，比如 alter table、drop table 等语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果要释放全局锁，则要执行这条命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然，当会话断开了，全局锁会被自动释放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全局锁应用场景是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局锁主要应用于做&lt;strong&gt;全库逻辑备份&lt;/strong&gt;，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。&lt;/p&gt;
&lt;h2 id=&#34;二-表级锁&#34;&gt;二、 表级锁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;MySQL 表级锁有哪些？具体怎么用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MySQL 里面表级别的锁有这几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元数据锁（MDL）;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意向锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AUTO-INC 锁；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;表锁&#34;&gt;表锁&lt;/h3&gt;
&lt;p&gt;表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。&lt;/p&gt;
&lt;p&gt;也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。&lt;/p&gt;
&lt;p&gt;另外，当会话退出后，也会释放所有表锁。&lt;/p&gt;
&lt;p&gt;不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。&lt;/p&gt;
&lt;h3 id=&#34;元数据锁mdl&#34;&gt;元数据锁(MDL)&lt;/h3&gt;
&lt;p&gt;我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对一张表进行 CRUD 操作时，加的是 &lt;strong&gt;MDL 读锁&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;对一张表做结构变更操作的时候，加的是 &lt;strong&gt;MDL 写锁&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。&lt;/p&gt;
&lt;p&gt;当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。&lt;/p&gt;
&lt;p&gt;反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MDL 不需要显示调用，那它是在什么时候释放的?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MDL 是在事务提交后才会释放，这意味着&lt;strong&gt;事务执行期间，MDL 是一直持有的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；&lt;/li&gt;
&lt;li&gt;然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；&lt;/li&gt;
&lt;li&gt;接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是因为申请 MDL 锁的操作会形成一个队列，队列中&lt;strong&gt;写锁获取优先级高于读锁&lt;/strong&gt;，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。&lt;/p&gt;
&lt;p&gt;所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。&lt;/p&gt;
&lt;h2 id=&#34;三行级锁&#34;&gt;三、行级锁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；&lt;/li&gt;
&lt;li&gt;在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>MySQL索引面试题</title>
      <link>http:04872.github.io/post/mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 17 Apr 2023 14:54:46 +0800</pubDate>
      
      <guid>http:04872.github.io/post/mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      
        <description>&lt;h1 id=&#34;mysql索引面试题&#34;&gt;MySQL索引面试题&lt;/h1&gt;
&lt;h3 id=&#34;1-索引分类&#34;&gt;1. &lt;strong&gt;索引分类&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按「数据结构」分类：&lt;strong&gt;B+tree索引、Hash索引、Full-text索引&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按「物理存储」分类：&lt;strong&gt;聚簇索引（主键索引）、二级索引（辅助索引）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按「字段特性」分类：&lt;strong&gt;主键索引、唯一索引、普通索引、前缀索引&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。&lt;/li&gt;
&lt;li&gt;唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。&lt;/li&gt;
&lt;li&gt;普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。&lt;/li&gt;
&lt;li&gt;前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按「字段个数」分类：&lt;strong&gt;单列索引、联合索引&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。&lt;/p&gt;
&lt;p&gt;在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果有主键，默认会使用主键作为聚簇索引的索引键（key）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；
其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是 B+Tree 索引。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;通过二级索引查询商品数据的过程&#34;&gt;通过二级索引查询商品数据的过程&lt;/h4&gt;
&lt;p&gt;主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；&lt;/li&gt;
&lt;li&gt;二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;联合索引&#34;&gt;联合索引&lt;/h4&gt;
&lt;p&gt;通过将多个字段组合成一个索引，该索引就被称为联合索引。&lt;/p&gt;
&lt;p&gt;比如，如果创建了一个 (a, b, c) 联合索引，联合索引查询的 B+Tree 是先按 a 进行排序，然后再 a 相同的情况再按 b 字段排序，然后再 b 相同的情况再按 c 字段排序。&lt;/p&gt;
&lt;p&gt;如果查询条件是以下这几种，就可以匹配上联合索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where a=1；&lt;/li&gt;
&lt;li&gt;where a=1 and b=2 and c=3；&lt;/li&gt;
&lt;li&gt;where a=1 and b=2；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。&lt;/p&gt;
&lt;p&gt;但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where b=2；&lt;/li&gt;
&lt;li&gt;where c=3；&lt;/li&gt;
&lt;li&gt;where b=2 and c=3；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。&lt;strong&gt;利用索引的前提是索引里的 key 是有序的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行where a = 2 and b = 7是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。&lt;/p&gt;
&lt;h3 id=&#34;2-索引底层使用了什么数据结构和算法&#34;&gt;2. &lt;strong&gt;索引底层使用了什么数据结构和算法？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;B+树、Hash表、 FULL-TEXT&lt;/p&gt;
&lt;h3 id=&#34;3-为什么-mysql-innodb-选择-btree-作为索引的数据结构&#34;&gt;3. &lt;strong&gt;为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。&lt;/li&gt;
&lt;li&gt;另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。&lt;/li&gt;
&lt;li&gt;对于有 N 个叶子节点的 B+Tree，其搜索复杂度为$\mathcal{O}(\log_{d}N)$，其中 d 表示节点允许的最大子节点个数为 d 个。&lt;/li&gt;
&lt;li&gt;在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。&lt;/li&gt;
&lt;li&gt;而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 $\mathcal{O}(\log N)$，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作。&lt;/p&gt;
&lt;p&gt;而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。&lt;/p&gt;
&lt;p&gt;但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。&lt;/p&gt;
&lt;p&gt;而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。&lt;/p&gt;
&lt;p&gt;另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。&lt;/p&gt;
&lt;h3 id=&#34;4-什么时候适用索引&#34;&gt;4. &lt;strong&gt;什么时候适用索引？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要占用物理空间，数量越大，占用空间越大；&lt;/li&gt;
&lt;li&gt;创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；&lt;/li&gt;
&lt;li&gt;会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，索引不是万能钥匙，它也是根据场景来使用的，以下情况适用索引。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字段有唯一性限制的，比如商品编码；&lt;/li&gt;
&lt;li&gt;经常用于 &lt;code&gt;WHERE&lt;/code&gt; 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。&lt;/li&gt;
&lt;li&gt;经常用于 &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-什么时候不需要创建索引&#34;&gt;5. &lt;strong&gt;什么时候不需要创建索引？&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 条件，&lt;code&gt;GROUP BY&lt;/code&gt;，&lt;code&gt;ORDER BY&lt;/code&gt; 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。&lt;/li&gt;
&lt;li&gt;字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。&lt;/li&gt;
&lt;li&gt;表数据太少的时候，不需要创建索引；&lt;/li&gt;
&lt;li&gt;经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-什么情况下索引会失效&#34;&gt;6. &lt;strong&gt;什么情况下索引会失效？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这里简单说一下，发生索引失效的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我们使用左或者左右模糊匹配的时候，也就是 &lt;code&gt;like %xx&lt;/code&gt; 或者 &lt;code&gt;like %xx%&lt;/code&gt;这两种方式都会造成索引失效；&lt;/li&gt;
&lt;li&gt;当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；&lt;/li&gt;
&lt;li&gt;联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。&lt;/li&gt;
&lt;li&gt;在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-有什么优化索引的方法&#34;&gt;7. &lt;strong&gt;有什么优化索引的方法？&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前缀索引优化；&lt;/p&gt;
&lt;p&gt;前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引。&lt;/p&gt;
&lt;p&gt;使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。&lt;/p&gt;
&lt;p&gt;不过，前缀索引有一定的局限性，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order by 就无法使用前缀索引；&lt;/li&gt;
&lt;li&gt;无法把前缀索引用作覆盖索引；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖索引优化；&lt;/p&gt;
&lt;p&gt;覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。&lt;/p&gt;
&lt;p&gt;假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？&lt;/p&gt;
&lt;p&gt;我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。&lt;/p&gt;
&lt;p&gt;所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主键索引最好是自增的；&lt;/p&gt;
&lt;p&gt;我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？&lt;/p&gt;
&lt;p&gt;InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们使用自增主键&lt;/strong&gt;，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次&lt;strong&gt;插入一条新记录，都是追加操作，不需要重新移动数据&lt;/strong&gt;，因此这种插入数据的方法效率非常高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们使用非自增主键&lt;/strong&gt;，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为&lt;strong&gt;页分裂&lt;/strong&gt;。&lt;strong&gt;页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止索引失效；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>项目简介</title>
      <link>http:04872.github.io/post/%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 11 Apr 2023 15:49:57 +0800</pubDate>
      
      <guid>http:04872.github.io/post/%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/</guid>
      
        <description>&lt;h2 id=&#34;项目介绍&#34;&gt;&lt;strong&gt;项目介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么要做这样一个项目？&lt;/p&gt;
&lt;p&gt;学习网络编程知识和锻炼实践能力.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;介绍下你的项目&lt;/p&gt;
&lt;p&gt;Linux下C++轻量级Web服务器。参考《Linux高性能服务器编程》&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;strong&gt;线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和Proactor均实现)&lt;/strong&gt; 的并发模型&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;状态机&lt;/strong&gt;解析HTTP请求报文，支持解析&lt;strong&gt;GET和POST&lt;/strong&gt;请求&lt;/li&gt;
&lt;li&gt;经Webbench压力测试可以实现&lt;strong&gt;上万的并发连接&lt;/strong&gt;数据交换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池相关&#34;&gt;&lt;strong&gt;线程池相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;手写线程池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程的同步机制有哪些？&lt;/p&gt;
&lt;p&gt;互斥锁和信号量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程池中的工作线程是一直等待吗？&lt;/p&gt;
&lt;p&gt;不是，会一直从任务队列取任务来执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你的线程池工作线程处理完一个任务后的状态是什么？&lt;/p&gt;
&lt;p&gt;释放该资源，等待执行下一任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？&lt;/p&gt;
&lt;p&gt;新来请求的要排队等着空闲线程处理，现在是固定线程池，最好的动态创建线程池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?&lt;/p&gt;
&lt;p&gt;会影响，使用异步的策略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并发模型相关&#34;&gt;&lt;strong&gt;并发模型相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单说一下服务器使用的并发模型？&lt;/p&gt;
&lt;p&gt;同步io模拟proactor+threadpool+epoll&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reactor、proactor、主从reactor模型的区别？&lt;/p&gt;
&lt;p&gt;主要就是主线程是否处理读写的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http报文解析相关&#34;&gt;&lt;strong&gt;HTTP报文解析相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用了状态机啊，为什么要用状态机？&lt;/li&gt;
&lt;li&gt;状态机的转移图画一下&lt;/li&gt;
&lt;li&gt;GET和POST的区别&lt;/li&gt;
&lt;li&gt;最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。&lt;/li&gt;
&lt;li&gt;GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。&lt;/li&gt;
&lt;li&gt;GET请求在URL中传送的参数是有长度限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。&lt;/li&gt;
&lt;li&gt;GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
  </channel>
</rss>
