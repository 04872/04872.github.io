<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lin</title>
    <link>http://04872.github.io/</link>
    <description>Recent content on Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 11 Apr 2023 15:49:57 +0800</lastBuildDate>
    
        <atom:link href="http://04872.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>项目简介</title>
      <link>http://04872.github.io/post/%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 11 Apr 2023 15:49:57 +0800</pubDate>
      
      <guid>http://04872.github.io/post/%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/</guid>
      
        <description>&lt;h2 id=&#34;项目介绍&#34;&gt;&lt;strong&gt;项目介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么要做这样一个项目？&lt;/p&gt;
&lt;p&gt;学习网络编程知识和锻炼实践能力.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;介绍下你的项目&lt;/p&gt;
&lt;p&gt;Linux下C++轻量级Web服务器。参考《Linux高性能服务器编程》&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;strong&gt;线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和Proactor均实现)&lt;/strong&gt; 的并发模型&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;状态机&lt;/strong&gt;解析HTTP请求报文，支持解析&lt;strong&gt;GET和POST&lt;/strong&gt;请求&lt;/li&gt;
&lt;li&gt;经Webbench压力测试可以实现&lt;strong&gt;上万的并发连接&lt;/strong&gt;数据交换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池相关&#34;&gt;&lt;strong&gt;线程池相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;手写线程池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程的同步机制有哪些？&lt;/p&gt;
&lt;p&gt;互斥锁和信号量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程池中的工作线程是一直等待吗？&lt;/p&gt;
&lt;p&gt;不是，会一直从任务队列取任务来执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你的线程池工作线程处理完一个任务后的状态是什么？&lt;/p&gt;
&lt;p&gt;释放该资源，等待执行下一任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？&lt;/p&gt;
&lt;p&gt;新来请求的要排队等着空闲线程处理，现在是固定线程池，最好的动态创建线程池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?&lt;/p&gt;
&lt;p&gt;会影响，使用异步的策略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并发模型相关&#34;&gt;&lt;strong&gt;并发模型相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单说一下服务器使用的并发模型？&lt;/p&gt;
&lt;p&gt;同步io模拟proactor+threadpool+epoll&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reactor、proactor、主从reactor模型的区别？&lt;/p&gt;
&lt;p&gt;主要就是主线程是否处理读写的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http报文解析相关&#34;&gt;&lt;strong&gt;HTTP报文解析相关&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用了状态机啊，为什么要用状态机？&lt;/li&gt;
&lt;li&gt;状态机的转移图画一下&lt;/li&gt;
&lt;li&gt;GET和POST的区别&lt;/li&gt;
&lt;li&gt;最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。&lt;/li&gt;
&lt;li&gt;GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。&lt;/li&gt;
&lt;li&gt;GET请求在URL中传送的参数是有长度限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。&lt;/li&gt;
&lt;li&gt;GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>我的测试呢</title>
      <link>http://04872.github.io/post/%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%91%A2/</link>
      <pubDate>Fri, 07 Apr 2023 16:48:26 +0800</pubDate>
      
      <guid>http://04872.github.io/post/%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%91%A2/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>Third</title>
      <link>http://04872.github.io/post/third/</link>
      <pubDate>Fri, 07 Apr 2023 16:32:22 +0800</pubDate>
      
      <guid>http://04872.github.io/post/third/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>Second</title>
      <link>http://04872.github.io/post/second/</link>
      <pubDate>Fri, 07 Apr 2023 16:21:28 +0800</pubDate>
      
      <guid>http://04872.github.io/post/second/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>First</title>
      <link>http://04872.github.io/post/first/</link>
      <pubDate>Fri, 07 Apr 2023 15:33:53 +0800</pubDate>
      
      <guid>http://04872.github.io/post/first/</guid>
      
        <description></description>
      
    </item>
    
  </channel>
</rss>
